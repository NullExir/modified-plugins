#!/usr/bin/python

# destination directory for sourcepawn files. relative to root.
destination_dir = [
	'source/command_menu',
	'source/confogl_system',
	'source/fix_null_activator',
	'source/l4d_spectator_prefix',
	'source/l4d_stats',
	'source/l4d_stucked_tank_teleport',
	'source/l4d2_block_aid_healing',
	'source/l4d2_block_no_steam_logon',
	'source/l4d2_cheer',
	'source/l4d2_dynamic_tank_health',
	'source/l4d2_ff_announcer_controller',
	'source/l4d2_getitem',
	'source/l4d2_hp_distributing',
	'source/l4d2_inputkill_block',
	'source/l4d2_item_hint',
	'source/l4d2_jockey_ride_stuck_fix',
	'source/l4d2_map_manager',
	'source/l4d2_mixmap',
	'source/l4d2_nightvision',
	'source/l4d2_playercount_based_supplies',
	'source/l4d2_playermanagement',
	'source/l4d2_practice_with_dominators',
	'source/l4d2_resolve_witch_ci_collision',
	'source/l4d2_scav_gascan_selfburn',
	'source/l4d2_scav_remove_blur_rumble',
	'source/l4d2_scav_weapon_consistency',
	'source/l4d2_setscores_scav',
	'source/l4d2_shove_kill_adjustment',
	'source/l4d2_tank_damage_control',
	'source/l4d2_throw_announce',
	'source/l4d2_welcome_message',
	'source/map_configs',
	'source/punch_angle',
	'source/saferoom_teleport',
	'source/savechat',
	'source/scavenge_quick_end',
	'source/sm_advertisement',
	'source/sm_hours_limiter',
	'source/sm_player_info',
	'source/sm_restarter',
	'source/spechud',
	'source/survivor_chat_select',
	'source/transition_restore_fix',
	'source/vote_manager',
]

# additional directories for sourcepawn include lookup. relative to root.
include_dirs = [
	'personal_sourcepawn_library_env'
]

# copy the include files generated by our plugins into the build output
release_include_dirs = [
	'include',
]

# required version of spcomp (presumably pinned to SM version)
# spcomp_min_version = (1, 12)

########################
# build.ninja script generation below.

import contextlib
import misc.ninja_syntax as ninja_syntax
import misc.spcomp_util
import os
import sys
import argparse
import platform
import shlex
import shutil
import subprocess

parser = argparse.ArgumentParser('Configures the project.')
parser.add_argument('--spcomp-dir', type = str,
		help = 'Directory with the SourcePawn compiler.  Will check PATH if not specified.')

parser.add_argument('--no-source', action = 'store_true', default = False, 
					help = 'Do not copy the source file into the build result.')

args = parser.parse_args()

print("""Checking for SourcePawn compiler...""")
spcomp = shutil.which('spcomp', path = args.spcomp_dir)
if 'x86_64' in platform.machine():
	# Use 64-bit spcomp if architecture supports it
	spcomp = shutil.which('spcomp64', path = args.spcomp_dir) or spcomp
if not spcomp:
	raise FileNotFoundError('Could not find SourcePawn compiler.')

# available_version = misc.spcomp_util.extract_version(spcomp)
# version_string = '.'.join(map(str, available_version))
# print('Found SourcePawn compiler version', version_string, 'at', os.path.abspath(spcomp))

# if spcomp_min_version > available_version:
# 	raise ValueError("Failed to meet required compiler version "
# 			+ '.'.join(map(str, spcomp_min_version)))

# properly handle quoting within params
if platform.system() == "Windows":
	arg_list = subprocess.list2cmdline
else:
	arg_list = shlex.join

with contextlib.closing(ninja_syntax.Writer(open('build.ninja', 'wt'))) as build:
	build.comment('This file is used to build SourceMod plugins with ninja.')
	build.comment('The file is automatically generated by configure.py')
	build.newline()
	
	vars = {
		'configure_args': arg_list(sys.argv[1:]),
		'root': '.',
		'builddir': 'build',
		'spcomp': spcomp,
		'spcflags': [ '-i ${root}', '-h', '-v0' ],
	}
	
	vars['spcflags'] += ('-i {}'.format(d) for d in include_dirs)
	
	for key, value in vars.items():
		build.variable(key, value)
	build.newline()
	
	build.comment("""Regenerate build files if build script changes.""")
	build.rule('configure',
			command = sys.executable + ' ${root}/configure.py ${configure_args}',
			description = 'Reconfiguring build', generator = 1)
	
	build.build('build.ninja', 'configure',
			implicit = [ '${root}/configure.py', '${root}/misc/ninja_syntax.py' ])
	build.newline()
	
	build.rule('spcomp', deps = 'msvc',
			command = '"${spcomp}" ${in} ${spcflags} -o ${out}',
			description = 'Compiling ${out}')
	build.newline()
	
	# Platform-specific copy instructions
	if platform.system() == "Windows":
		build.rule('copy', command = 'cmd /c copy ${in} ${out} > NUL',
				description = 'Copying ${out}')
	elif platform.system() == "Linux":
		build.rule('copy', command = 'cp ${in} ${out}', description = 'Copying ${out}')
	build.newline()

	build.comment("""Compile plugins specified in `destination_dir` list""")
	for dest_dir in destination_dir:
		dir = os.path.normpath(os.path.join(vars['root'], dest_dir, 'scripting'))
		for root, dirs, files in os.walk(dir):
			if not args.no_source:
				for file in files:
					# Copy all files 
					file_path = os.path.join(root, file)
					dist_sp = os.path.normpath(os.path.join(vars['builddir'], file_path))
					build.build(dist_sp, 'copy', file_path)
					build.newline()

			for subdir in dirs:
				# Add this directory as an include path
				root_subdir = os.path.join(root, subdir)
				include_path = '-i {}'.format(root_subdir)
				if include_path not in vars['spcflags']:
					vars['spcflags'] += include_path

		# Ignore if there's no source files.
		if not os.path.isdir(dir):
			continue

		# Only process files in the top-level scripting directory
		for file in os.listdir(dir):
			file_path = os.path.join(dir, file)

			if os.path.isfile(file_path):
				if file.endswith('.sp'):  # Only compile .sp files
					smx_plugin = os.path.splitext(file)[0] + '.smx'
					smx_file = os.path.normpath(os.path.join(vars['builddir'], dest_dir, 'plugins', smx_plugin))
					build.build(smx_file, 'spcomp', file_path) # Compile SourcePawn files to SMX
					build.newline()
				
	build.newline()
	
	build.comment("""Copy other files from source tree""")
	for filepath in destination_dir:
		dir_data = os.path.normpath(os.path.join(vars['root'], filepath, 'data'))
		for root, subdir_data, files in os.walk(dir_data):
			for file in files:
				filepath_data = os.path.join(root, file)
				dist_to_copy = os.path.normpath(os.path.join(vars['builddir'], filepath_data))
				build.build(dist_to_copy, 'copy', os.path.normpath(os.path.join(vars['root'], filepath_data)))
				build.newline()
		
		dir_configs = os.path.normpath(os.path.join(vars['root'], filepath, 'configs'))
		for root, subdir_configs, files in os.walk(dir_configs):
			for file in files:
				filepath_configs = os.path.join(root, file)
				dist_to_copy = os.path.normpath(os.path.join(vars['builddir'], filepath_configs))
				build.build(dist_to_copy, 'copy', os.path.normpath(os.path.join(vars['root'], filepath_configs)))
				build.newline()

		dir_translations = os.path.normpath(os.path.join(vars['root'], filepath, 'translations'))
		for root, subdir_translations, files in os.walk(dir_translations):
			for file in files:
				filepath_translations = os.path.join(root, file)
				dist_to_copy = os.path.normpath(os.path.join(vars['builddir'], filepath_translations))
				build.build(dist_to_copy, 'copy', os.path.normpath(os.path.join(vars['root'], filepath_translations)))
				build.newline()

		# Copy other files in destination directory, usually a readme.
		for file in os.listdir(filepath):
			file_path = os.path.join(filepath, file)
			if os.path.isfile(file_path):
				dist_to_copy = os.path.normpath(os.path.join(vars['builddir'], file_path))
				build.build(dist_to_copy, 'copy', os.path.normpath(os.path.join(vars['root'], file_path)))
				build.newline()

	build.newline()
	build.comment("""Copy include files to build output""")
	for include_dir in release_include_dirs:
		include_path = os.path.normpath(os.path.join(vars['root'], include_dir))
		for root, dirs, files in os.walk(include_path):
			for file in files:
				file_path = os.path.join(root, file)
				dist_to_copy = os.path.normpath(os.path.join(vars['builddir'], 'include', file))
				build.build(dist_to_copy, 'copy', file_path)